<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
			}
			#info {
				position: absolute;
				top: 0px;
				width: 100%;
				color: #000000;
				padding: 5px;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;
				z-index: 1;
			}

			a {
				color: #000000;
			}

		</style>
	</head>
	<body>
		<div id="info"><a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - Interactive Games</div>

		<script src="build/three.js"></script>

		<script src="cameraControls.js"></script>

		<script src="CSS3DRenderer.js"></script>

		<script>

			var camera, scene, renderer;

			var scene2, renderer2;

			var controls;
			const CUBE_WIDTH = 1;
			const CUBE_HEIGHT = 1;
			const CUBE_DEPTH = 0.25;
			var maze;

			createWorld();
			animate();

			function createWorld() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 200, 200, 200 );

				controls = new THREE.cameraControls( camera );

				scene = new THREE.Scene();
				//scene.background = new THREE.Color( 0xf0f0f0 );

				scene2 = new THREE.Scene();
				var light = new THREE.DirectionalLight();
				light.position.set(200, 200, 200 );
				camera.add(light);
				scene.add(camera);

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				renderer2 = new THREE.CSS3DRenderer();
				renderer2.setSize( window.innerWidth, window.innerHeight );
				renderer2.domElement.style.position = 'absolute';
				renderer2.domElement.style.top = 0;
				document.body.appendChild( renderer2.domElement );

				createMaze();
   				createGround();

			}
			
function createMaze() {

	maze = [
			[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],
			[1,0,1,0,0,0,0,0,1,0,0,0,1,0,1],
			[1,1,1,1,1,0,1,1,1,1,1,1,1,0,1],
			[1,0,0,0,1,0,1,0,0,0,0,0,1,0,1],
			[1,1,1,1,1,1,1,1,1,1,1,0,1,0,1],
			[1,0,1,1,1,1,1,1,1,0,1,0,1,0,1],
			[1,1,1,0,0,1,0,0,0,0,1,0,1,1,1],
			[1,0,1,0,1,1,1,1,1,1,0,0,1,0,1],
			[1,0,1,1,1,1,0,0,1,0,1,1,1,0,1],
			[1,0,1,0,0,1,1,1,1,1,1,0,1,0,1],
			[1,1,1,1,0,1,0,1,0,1,0,0,1,0,1],
			[1,0,1,0,0,1,0,1,0,1,1,1,1,0,1],
			[1,0,1,1,1,1,0,1,0,0,0,0,1,1,1],
			[1,0,0,1,0,0,0,1,1,1,1,1,1,0,1],
			[1,1,1,1,1,1,1,1,1,1,1,1,1,0,1]
		]

	var cubeGeo = new THREE.BoxGeometry(CUBE_WIDTH, CUBE_HEIGHT, CUBE_DEPTH);
	var cubeMat = new THREE.MeshPhongMaterial({
						color: 0x81cfe0,
						//specular: 0x222222,
						//shininess: 16,
						shading: THREE.FlatShading
					});

	var widthOffSet = CUBE_WIDTH/2;
	var heightOffSet = CUBE_HEIGHT/2;
	var totalCubesWide = maze[0].length;

	// NOTE: by default cubes are drawn horizontally
	for(var i = 0; i < totalCubesWide; i++) {
		for(var j = 0; j < maze[i].length; j++) {

			if(maze[i][j] == 1) {
				var cube = new THREE.Mesh(cubeGeo, cubeMat);

				cube.position.x = (j - totalCubesWide/2) + widthOffSet;
				// raise the cubes to sit on the x-axis (level of the ground for the maze).
				cube.position.y = heightOffSet;
				cube.position.z = (i - totalCubesWide/2);

				// left wall
				if(j == 0) {
					cube.position.x = (j - totalCubesWide/2) + CUBE_WIDTH;
					cube.rotation.y = Math.PI/2;
				}

				// right wall
				else if(j == maze[i].length-1) {
					cube.position.x = (j - totalCubesWide/2);
					cube.rotation.y = Math.PI/2;
				}

				// if a position has a 1 and zeros to the left and right and there's a 1 below
				// the current position rotate the cube -90 degrees
				// 0 1 0
				//   1
				if(j-1 >= 0 && j+1 <= maze[i].length-2 && i+1 < totalCubesWide) {
					if(maze[i][j-1] == 0 && maze[i][j+1] == 0 && maze[i+1][j] == 1) {
						cube.position.x = (j - totalCubesWide/2);
						cube.rotation.y = -Math.PI/2;
						cube.position.z = (i - totalCubesWide/2) - widthOffSet - 0.12;
					}
				} 
				

				// if a position has a 1 and zeros to the left and right and there's a 1 above
				// the current position rotate the cube 90 degrees
				//   1 
				// 0 1 0
				if(j-1 >= 0 && j+1 <= maze[i].length-2 && i-1 >= 0) {
					if(maze[i][j-1] == 0 && maze[i][j+1] == 0 && maze[i-1][j] == 1) {
						cube.position.x = (j - totalCubesWide/2);
						cube.rotation.y = Math.PI/2;
						cube.position.z = (i - totalCubesWide/2) - widthOffSet - 0.12;
					}
				}

				scene.add(cube);
				
			}
		}
	}

}
function createGround() {

var groundGeo = new THREE.PlaneGeometry(20, 20);
var groundMat = new THREE.MeshPhongMaterial({color: 0xFFFFFF, side: THREE.DoubleSide});
var ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

}


			
function animate() {

	requestAnimationFrame( animate );

		controls.update();

		renderer.render( scene, camera );
		renderer2.render( scene2, camera );

		}

		</script>
	</body>
</html>
